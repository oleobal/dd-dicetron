#!/usr/bin/env python3
import discord
import os
import subprocess
from collections import deque
from struct import pack
import re

history_command_regex = re.compile(r"!(!|[0-9]+)")


history = {}


def add_history_item(ident, item):
    if ident not in history:
        history[ident] = deque(maxlen=10)
    history[ident].appendleft(item)


def get_history_item(ident, index):
    return history.get(ident, [])[index]


def get_pretty_history(ident):
    h = history.get(ident, [])
    msg = ""
    for i in reversed(range(len(h))):
        msg += f"{i:>2} {h[i]}\n"
    return msg


# copy of Kotlin's trimIndent
def trim_indent(s: str) -> str:
    source = s.splitlines()
    while source[0] == "":
        source = source[1:]
    while source[-1] == "":
        source = source[:-1]
    leading = ""
    for i in range(len(source[0])):
        if source[0][i].isspace():
            leading += source[0][i]
        else:
            break
    source = [s[len(leading) :] for s in source]
    # while source[0] == "":
    #    source=source[1:]
    # while source[-1] == "":
    #    source=source[:-1]
    return "\n".join(source)


client = discord.Client()

trigger = "!r"


@client.event
async def on_ready():
    print("We have logged in as {0.user}".format(client))


@client.event
async def on_message(message):
    if message.author == client.user:
        return

    if message.content.startswith(trigger):
        command = message.content[len(trigger) :]
        cmd_from_history = None
        author_id = b"%x%x" % (
            message.author.id,
            message.channel.id,
        )  # not optimal but close enough
        if command.strip().casefold() == "help":
            await message.reply(
                trim_indent(
                    f"""
                    Prefix all commands with `{trigger}` (eg `{trigger} 1d20`)
                    ```
                    """
                )
                + get_dice_help()
                + trim_indent(
                    """
                    
                    Comments:                         2d4+1 # Great axe damage
                    
                    List last rolls:                  history
                    reroll the last one:            !!
                    reroll the one with index 7:    !7
                    ```
                    Source: `https://github.com/oleobal/dd-dicetron`
                    """
                )
            )
            return
        elif command.strip().casefold() == "history":
            h = get_pretty_history(author_id)
            if h:
                msg = f"History for {message.author.display_name}:\n```\n{h}\n```_(`!!` or `!<index>` to use)_"
            else:
                msg = f"You have no rolling history on this channel"
            await message.reply(msg)
            return
        elif match := history_command_regex.match(command.strip().casefold()):
            if match.group(1) == "!":
                index = 0
            else:
                index = int(match.group(1))
            try:
                cmd_from_history = get_history_item(author_id, index)
            except IndexError:
                await message.reply(f":warning: No history item no.{index}")
                return

        if cmd_from_history:
            dice_expr, *comment = cmd_from_history.split("#", maxsplit=1)
        else:
            dice_expr, *comment = command.split("#", maxsplit=1)
        went_fine, response = roll_dice(dice_expr)

        if cmd_from_history and command.strip() != "!!":
            response = "`" + cmd_from_history.strip() + "` " + response
        response = ("_" + comment[0].strip() + "_ " if comment else "") + response

        if went_fine:
            if not cmd_from_history:
                add_history_item(author_id, command)
        else:
            response = ":warning: " + response

        await message.reply(response)


def get_dice_help():
    p = subprocess.run([os.environ["DD_DICE_PATH"], "--help"], capture_output=True)
    if p.returncode == 0:
        return p.stdout.decode("utf-8")
    else:
        return "Error"


def roll_dice(expr) -> tuple[bool, str]:
    p = subprocess.run(
        [os.environ["DD_DICE_PATH"], "--machine", expr], capture_output=True
    )
    if p.returncode == 0:
        lines = p.stdout.decode("utf-8").split("\n")
        if len(lines[0]) > 100:
            lines[0] = "[too long]"
        if len(lines[2]) > 0:  # error
            return (False, lines[2])
        return (True, "`" + lines[0] + "`: **" + lines[1] + "**")
    else:
        return (False, "Error")


def main():
    assert "DD_DISCORD_API_TOKEN" in os.environ
    assert "DD_DICE_PATH" in os.environ

    client.run(os.environ["DD_DISCORD_API_TOKEN"])


if __name__ == "__main__":
    main()
